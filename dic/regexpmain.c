/* Eliot                                                                     */
/* Copyright (C) 1999  antoine.fraboulet                                     */
/* antoine.fraboulet@free.fr                                                 */
/*                                                                           */
/* This program is free software; you can redistribute it and/or modify      */
/* it under the terms of the GNU General Public License as published by      */
/* the Free Software Foundation; either version 2 of the License, or         */
/* (at your option) any later version.                                       */
/*                                                                           */
/* This program is distributed in the hope that it will be useful,           */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
/* GNU General Public License for more details.                              */
/*                                                                           */
/* You should have received a copy of the GNU General Public License         */
/* along with this program; if not, write to the Free Software               */
/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
/*
 * $Id: regexpmain.c,v 1.3 2005/04/18 17:40:36 afrab Exp $
 */
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "regexp.h"
#include "regexp-er.h" /* generated by bison */
#include "scanner.h"   /* generated by flex  */
#include "automaton.h"

#ifndef PDBG
#ifdef DEBUG
#define PDBG(x) { x ; }
#else
#define PDBG(x) { }
#endif
#endif

extern int yyparse(yyscan_t scanner, NODE ** root);


int buildauto(char* er)
{
  int i,p,n,value;

  int ptl[REGEXP_MAX+1]; 
  int PS [REGEXP_MAX+1]; 

  NODE* root;
  yyscan_t scanner;
  YY_BUFFER_STATE buf;

  automaton a;

  char stringbuf[250];

  /* (expr)# */
  sprintf(stringbuf,"(%s)#",er);

  for(i=0; i < REGEXP_MAX; i++)
    {
      PS[i] = 0;
      ptl[i] = 0;
    }

  yylex_init( &scanner );
  buf   = yy_scan_string( stringbuf, scanner );
  root  = NULL;
  value = yyparse( scanner , &root);
  yy_delete_buffer(buf,scanner);
  yylex_destroy( scanner );

  if (value)
    {
      regexp_delete_tree(root);
      return 1;
    }

  n = 1;
  p = 1;
  regexp_parcours(root, &p, &n, ptl);
  PS [0] = p - 1;
  ptl[0] = p - 1;

  /*  
  printf("** regexp: nombre de terminaux: %d\n",PS[0]);
  printf("** regexp: nombre de noeuds dans l'arbre: %d\n",n);
  printf("** position des lettres : \n");
  regexp_print_ptl(ptl);
  */

  regexp_possuivante(root,PS);

  /*
  regexp_print_tree(root,"tree",1);
  regexp_print_PS(PS);
  */

  a = automaton_build(root->PP,ptl,PS);

  /*
  printf("** auto: nombre d'états: %d\n",a->nstate);
  */

  automaton_dump(a,"auto");
  automaton_delete(a);
  regexp_delete_tree(root);
  return 0;
}

void yyerror (yyscan_t yyscanner, NODE** root, char const *msg)
{
  printf("\n erreur ! (%s)\n",msg);
}


int main(int argc, char* argv[])
{
  char stringbuf[200];
  strcpy(stringbuf,".");

  while (strcmp(stringbuf,""))
    {
      fprintf(stdout,"entrer une ER:\n");
      fgets(stringbuf,sizeof(stringbuf),stdin);
      /* strip \n */
      stringbuf[strlen(stringbuf) - 1] = '\0';
      /* automaton */
      buildauto(stringbuf);
    }
  return 0;
}
