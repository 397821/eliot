/*****************************************************************************
 * Eliot
 * Copyright (C) 2010 Olivier Teulière
 * Authors: Olivier Teulière <ipkiss @@ gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *****************************************************************************/

#include <iostream>

#include <QtGui/QLabel>
#include <QtGui/QVBoxLayout>
#include <QtGui/QFileDialog>
#include <QtGui/QStandardItemModel>
#include <QtGui/QMessageBox>
#include <QtCore/QFile>
#include <QtCore/QTextStream>
#include <QtCore/QSet>
#include <QtCore/QList>

#include "dic_wizard.h"
#include "qtcommon.h"

using namespace std;


// ---------- WizardInfoPage ----------

WizardInfoPage::WizardInfoPage(QWidget *parent) : QWizardPage(parent)
{
    setupUi(this);

    // Define the labels properly
    setTitle(_q("General information"));
    setSubTitle(_q("On this page, you can define the main information "
                   "needed to create a new dictionary."));
    labelDicNameDesc->setText(_q("Choose a dictionary name. This name will "
                                 "appear in Eliot status bar when the "
                                 "dictionary is loaded.\nE.g.: My Dic 1.0"));
    labelGenDicDesc->setText(_q("Choose the output file. This file will be "
                                "generated by the wizard, and will contain "
                                "the compressed dictionary.\n"
                                "It must have the .dawg extension."));
    labelWordListDesc->setText(_q("Choose the file containing the word list.\n"
                                  "It must be encoded in UTF-8, and must "
                                  "contain one word on each line."));

    // Handle the Browse buttons
    connect(buttonBrowseGenDic, SIGNAL(clicked(bool)),
            this, SLOT(onBrowseGenDicClicked()));
    connect(buttonBrowseWordList, SIGNAL(clicked(bool)),
            this, SLOT(onBrowseWordListClicked()));

    // Connection needed for proper calls to the isComplete() method
    connect(editGenDic, SIGNAL(textChanged(const QString&)),
            this, SIGNAL(completeChanged()));

    // Register fields and make them mandatory
    registerField("dicName*", editDicName);
    registerField("genDic*", editGenDic);
    registerField("wordList*", editWordList);
}


bool WizardInfoPage::isComplete() const
{
    return true; // XXX XXX XXX: temporary
    if (!QWizardPage::isComplete())
        return false;

    // Make sure the word list file exists
    if (!QFile(editWordList->text()).exists())
        return false;

    // Make sure the generated file has the .dawg extension
    return editGenDic->text().endsWith(".dawg");
}


bool WizardInfoPage::validatePage()
{
    // Parse the file to get all the characters
    QFile file(editWordList->text());
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return false;

    QMap<QChar, int> lettersWithLine;
    int lineNb = 1;
    QTextStream in(&file);
    while (!in.atEnd()) {
        QString line = in.readLine().toUpper();
        for (int i = 0; i < line.size(); ++i)
        {
            if (!lettersWithLine.contains(line[i]))
                lettersWithLine.insert(line[i], lineNb);
        }
        ++lineNb;
    }

    // Copy the bad chars (i.e. non letters) to a list
    QMap<QChar, int>::const_iterator it;
    QList<QChar> badChars;
    for (it = lettersWithLine.begin(); it != lettersWithLine.end(); ++it)
    {
        if (!it.key().isLetter())
            badChars.push_back(it.key());
    }

    // If the list is not empty, then the word list is invalid
    if (!badChars.empty())
    {
        QString msg = _q("Some invalid (non-alphabetical) characters have "
                         "been found in the word list. They are indicated "
                         "below, with the first line on which they were found:");
        foreach (QChar ch, badChars)
        {
            QString letterMsg = "\n\t" + _q("'%1' (ASCII code %2) at line %3");
            msg += letterMsg.arg(ch).arg((int)ch.toAscii()).arg(lettersWithLine[ch]);
        }
        QMessageBox errorBox(QMessageBox::Critical, _q("Eliot"), msg,
                             QMessageBox::Ok);
        errorBox.setInformativeText(_q("Please correct the word list."));
        errorBox.exec();

        return false;
    }

    return true;
}


void WizardInfoPage::onBrowseGenDicClicked()
{
    QString fileName = QFileDialog::getSaveFileName(this,
            _q("Choose a file for the generated dictionary"), "", "*.dawg");
    if (fileName != "")
    {
        if (!fileName.endsWith(".dawg"))
            fileName += ".dawg";
        editGenDic->setText(fileName);
    }
}


void WizardInfoPage::onBrowseWordListClicked()
{
    QString fileName = QFileDialog::getOpenFileName(this,
            _q("Choose a word list file"));
    if (fileName != "")
        editWordList->setText(fileName);
}


// ---------- WizardLettersDefPage ----------

WizardLettersDefPage::WizardLettersDefPage(QWidget *parent) : QWizardPage(parent)
{
    setupUi(this);

    setTitle(_q("Letters characteristics"));
    labelTableDesc->setText(_q("The table below lists all the letters found in the word list (plus the joker). "
            "For each letter, you need to define:\n"
            " - its number of points;\n"
            " - its frequency (number of occurrences in the game);\n"
            " - whether the letter can be considered as a vowel;\n"
            " - whether the letter can be considered as a consonant.\n"
            "\n"
            "Note that a letter can be considered both as a vowel and as a consonant. "
            "This is usually the case for the joker and, in French, for the Y letter."));

    // Create the model
    m_model = new QStandardItemModel(0, 5, this);
    m_model->setHeaderData(0, Qt::Horizontal, _q("Letter"), Qt::DisplayRole);
    m_model->setHeaderData(1, Qt::Horizontal, _q("Points"), Qt::DisplayRole);
    m_model->setHeaderData(2, Qt::Horizontal, _q("Frequency"), Qt::DisplayRole);
    m_model->setHeaderData(3, Qt::Horizontal, _q("Vowel?"), Qt::DisplayRole);
    m_model->setHeaderData(4, Qt::Horizontal, _q("Consonant?"), Qt::DisplayRole);
    tableLetters->setModel(m_model);
    treeLetters->setModel(m_model);
    treeLetters->header()->setDefaultAlignment(Qt::AlignCenter);

    connect(buttonLoadLetters, SIGNAL(clicked(bool)),
            this, SLOT(loadLettersFromWordList()));
    connect(buttonRemoveLetter, SIGNAL(clicked(bool)),
            this, SLOT(removeLetter()));
    // Enable the Remove button only when there is a selection in the tree
    connect(treeLetters->selectionModel(),
            SIGNAL(selectionChanged(const QItemSelection&, const QItemSelection&)),
            this,
            SLOT(enableRemoveButton(const QItemSelection&)));
}


void WizardLettersDefPage::loadLettersFromWordList()
{
    // Parse the file to get all the letters
    QFile file(field("wordList").toString());
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;

    QSet<QChar> fileLetters;
    QTextStream in(&file);
    while (!in.atEnd()) {
        QString line = in.readLine().toUpper();
        for (int i = 0; i < line.size(); ++i)
        {
            fileLetters.insert(line[i]);
        }
    }

    // Sort the letters alphabetically if possible
    QList<QChar> sortedLetters = QList<QChar>::fromSet(fileLetters);
    qSort(sortedLetters);

    // Rebuild the model
    m_model->removeRows(0, m_model->rowCount());
    foreach (QChar ch, sortedLetters)
    {
        const int rowNum = m_model->rowCount();
        bool res = m_model->insertRow(rowNum);
        if (!res)
            return;
        m_model->setData(m_model->index(rowNum, 0), ch);
        m_model->setData(m_model->index(rowNum, 1), 0);
        m_model->setData(m_model->index(rowNum, 2), 0);
        m_model->setData(m_model->index(rowNum, 3),
                         (bool)QString("AEIOUY").contains(ch));
        m_model->setData(m_model->index(rowNum, 4),
                         (bool)QString("AEIOU").contains(ch));
    }

    // Add another line for the joker
    int rowNum = m_model->rowCount();
    bool res = m_model->insertRow(rowNum);
    if (!res)
        return;
    m_model->setData(m_model->index(rowNum, 0), QString(_q("? (joker)")));
    m_model->setData(m_model->index(rowNum, 1), 0);
    m_model->setData(m_model->index(rowNum, 2), 2);
    m_model->setData(m_model->index(rowNum, 3), true);
    m_model->setData(m_model->index(rowNum, 4), true);

    // Align everything in the center and prevent editing in the first column
    for (int i = 0; i < m_model->rowCount(); ++i)
    {
        m_model->item(i, 0)->setEditable(false);
        for (int j = 0; j < m_model->columnCount(); ++j)
        {
            m_model->item(i, j)->setTextAlignment(Qt::AlignCenter);
        }
    }
}


void WizardLettersDefPage::enableRemoveButton(const QItemSelection &iSelected)
{
    // Enable the "Remove" button iff at least one line in the tree view
    // is selected
    buttonRemoveLetter->setEnabled(!iSelected.indexes().empty());
}


void WizardLettersDefPage::removeLetter()
{
    QModelIndexList indexList = treeLetters->selectionModel()->selectedIndexes();
    if (indexList.empty())
        return;

    // Warn the user of the consequences
    QString msg = _q("If you remove this letter, the only way to play words "
                     "containing this letter will be to use the joker tile(s). "
                     "This might be wanted in some rare cases, but it is "
                     "usually better to remove the words containing the "
                     "unwanted letter from the word list.");
    QMessageBox confoBox(QMessageBox::Warning, _q("Eliot"), msg,
                         QMessageBox::Yes | QMessageBox::No, this);
    confoBox.setInformativeText(_q("Do you really want to continue?"));
    confoBox.setDefaultButton(QMessageBox::Yes);
    confoBox.setEscapeButton(QMessageBox::No);
    int ret = confoBox.exec();
    if (ret != QMessageBox::Yes)
        return;

    m_model->removeRow(indexList.front().row());
}


bool WizardLettersDefPage::isComplete() const
{
    if (!QWizardPage::isComplete())
        return false;

    // TODO
    return true;
}


// ---------- DicWizard ----------

DicWizard::DicWizard(QWidget *parent)
    : QWizard(parent)
{
    setOption(QWizard::IndependentPages);
    addPage(new WizardInfoPage);
    addPage(new WizardLettersDefPage());
    // TODO
}

